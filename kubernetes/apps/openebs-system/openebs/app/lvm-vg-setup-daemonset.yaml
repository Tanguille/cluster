---
# DaemonSet to automatically create LVM volume group 'lvmvg' on nodes
# This runs on nodes with storage.lvm/available: "true" label
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: lvm-vg-setup
  namespace: openebs-system
  labels:
    app: lvm-vg-setup
spec:
  selector:
    matchLabels:
      app: lvm-vg-setup
  template:
    metadata:
      labels:
        app: lvm-vg-setup
    spec:
      hostNetwork: true
      hostPID: true
      nodeSelector:
        storage.lvm/available: "true"
      tolerations:
        - effect: NoSchedule
          operator: Exists
      containers:
        - name: lvm-setup
          # Alpine is small and LVM install is fast; script is idempotent so only runs once
          image: alpine:3.23
          imagePullPolicy: IfNotPresent
          securityContext:
            privileged: true
            capabilities:
              add:
                - SYS_ADMIN
                - MKNOD
          volumeMounts:
            - name: dev
              mountPath: /dev
            - name: sys
              mountPath: /sys
            - name: run
              mountPath: /run
            - name: etc-lvm
              mountPath: /etc/lvm
            - name: var-lib-lvm
              mountPath: /var/lib/lvm
            - name: proc
              mountPath: /host/proc
              readOnly: true
          command:
            - /bin/sh
            - -c
            - |
              set -euo pipefail

              # Install LVM tools (only if not present - cached after first run)
              if ! command -v vgs &>/dev/null; then
                apk add --no-cache --quiet lvm2 util-linux coreutils
              fi

              # Check if VG already exists
              if vgs lvmvg &>/dev/null; then
                echo "✓ Volume group 'lvmvg' already exists"
                vgs lvmvg
                exec sleep infinity
              fi

              echo "Searching for available disk for LVM volume group 'lvmvg'..."

              # Get root device (handle both /dev/xxx and /dev/disk/by-xxx)
              root_source=$(findmnt -n -o SOURCE / 2>/dev/null || echo "")
              root_dev=""
              if [ -n "$root_source" ]; then
                # Resolve symlinks to actual device (readlink -f from coreutils, fallback to basic resolution)
                if command -v readlink &>/dev/null && readlink -f "$root_source" &>/dev/null; then
                  root_dev=$(readlink -f "$root_source")
                else
                  # Fallback: try to resolve manually or use as-is
                  root_dev=$(readlink "$root_source" 2>/dev/null || echo "$root_source")
                  # If it's still a by-id path, try to resolve it
                  if [ "${root_dev#/dev/disk}" != "$root_dev" ]; then
                    root_dev=$(ls -l "$root_dev" 2>/dev/null | awk '{print $NF}' || echo "$root_dev")
                  fi
                fi
                # Remove partition number
                root_dev=$(echo "$root_dev" | sed 's/[0-9]*$//')
                echo "Root device: $root_dev"
              fi

              # Function to check if device is safe to use
              is_device_safe() {
                local dev=$1

                # Must be a block device
                [ -b "$dev" ] || return 1

                # Skip if it's the root device
                [ "$dev" = "$root_dev" ] && return 1

                # Skip if device is already a physical volume
                pvs "$dev" &>/dev/null && return 1

                # Skip if device itself is mounted (shouldn't happen for raw disks, but check)
                mountpoint -q "$dev" 2>/dev/null && return 1

                # Check if device has partitions that are in use
                local dev_name=${dev##*/}
                # Get all partitions for this device
                while IFS= read -r part_line; do
                  part_name=$(echo "$part_line" | awk '{print $1}')
                  part_type=$(echo "$part_line" | awk '{print $2}')
                  part_mount=$(echo "$part_line" | awk '{print $3}')

                  # Only check actual partitions (not the base device)
                  [ "$part_type" != "part" ] && continue
                  # Skip if this is the base device itself (shouldn't happen, but be safe)
                  [ "$part_name" = "$dev_name" ] && continue

                  # Check if partition name starts with device name (handles nvme0n1 -> nvme0n1p1)
                  case "$part_name" in
                    ${dev_name}*) ;;
                    *) continue ;;  # Not a partition of this device
                  esac

                  part_dev="/dev/$part_name"
                  # If partition is mounted, device is in use
                  [ -n "$part_mount" ] && return 1
                  # If partition is a PV, device is in use
                  pvs "$part_dev" &>/dev/null && return 1
                done < <(lsblk -n -o NAME,TYPE,MOUNTPOINT "$dev" 2>/dev/null)

                # Must be at least 10GB
                local size
                size=$(blockdev --getsize64 "$dev" 2>/dev/null || echo 0)
                [ "$size" -lt 10737418240 ] && return 1

                return 0
              }

              # Search for available disk, prefer by-id paths for stability
              found=false

              # First, try /dev/disk/by-id paths (more stable)
              while IFS= read -r byid_path; do
                [ -z "$byid_path" ] && continue
                # Resolve symlink to actual device
                if command -v readlink &>/dev/null && readlink -f "$byid_path" &>/dev/null; then
                  actual_dev=$(readlink -f "$byid_path")
                else
                  # Fallback: use ls to resolve symlink
                  actual_dev=$(ls -l "$byid_path" 2>/dev/null | awk '{print $NF}' || echo "")
                  # If still a relative path, make it absolute
                  [ "${actual_dev#/}" = "$actual_dev" ] && actual_dev="/dev/$actual_dev"
                fi
                [ -z "$actual_dev" ] && continue

                # Remove partition suffix to get base device
                base_dev=$(echo "$actual_dev" | sed 's/[0-9]*$//')

                if is_device_safe "$base_dev"; then
                  echo "✓ Found suitable disk: $byid_path -> $base_dev"
                  echo "Creating physical volume on $base_dev..."
                  if pvcreate -y "$base_dev"; then
                    echo "Creating volume group 'lvmvg' on $base_dev..."
                    if vgcreate -y lvmvg "$base_dev"; then
                      echo "✓ Successfully created volume group 'lvmvg'"
                      vgs lvmvg
                      found=true
                      break
                    else
                      echo "✗ Failed to create volume group, removing physical volume..."
                      pvremove -y "$base_dev" 2>/dev/null || true
                    fi
                  else
                    echo "✗ Failed to create physical volume on $base_dev"
                  fi
                fi
              done < <(find /dev/disk/by-id -type l 2>/dev/null | grep -vE "(part|wwn-)" | head -20)

              # Fallback to direct device paths if by-id didn't work
              if [ "$found" = false ]; then
                echo "Trying direct device paths..."
                for pattern in /dev/nvme[0-9]n1 /dev/sd[b-z] /dev/vd[b-z]; do
                  for dev in $pattern; do
                    [ ! -e "$dev" ] && continue
                    base_dev=$(echo "$dev" | sed 's/[0-9]*$//')
                    [ "$dev" != "$base_dev" ] && continue  # Skip partitions

                    if is_device_safe "$base_dev"; then
                      echo "✓ Found suitable disk: $base_dev"
                      echo "Creating physical volume on $base_dev..."
                      if pvcreate -y "$base_dev"; then
                        echo "Creating volume group 'lvmvg' on $base_dev..."
                        if vgcreate -y lvmvg "$base_dev"; then
                          echo "✓ Successfully created volume group 'lvmvg'"
                          vgs lvmvg
                          found=true
                          break 2
                        else
                          echo "✗ Failed to create volume group, removing physical volume..."
                          pvremove -y "$base_dev" 2>/dev/null || true
                        fi
                      else
                        echo "✗ Failed to create physical volume on $base_dev"
                      fi
                    fi
                  done
                done
              fi

              if [ "$found" = false ]; then
                echo "✗ ERROR: No suitable disk found for LVM volume group"
                echo ""
                echo "Available block devices:"
                lsblk -o NAME,SIZE,TYPE,MOUNTPOINT,FSTYPE
                echo ""
                echo "Existing physical volumes:"
                pvs 2>/dev/null || echo "  (none)"
                echo ""
                echo "Existing volume groups:"
                vgs 2>/dev/null || echo "  (none)"
                exec sleep infinity
              fi

              # Keep running to maintain the setup
              exec sleep infinity
          resources:
            requests:
              cpu: 10m
              memory: 64Mi
            limits:
              cpu: 100m
              memory: 256Mi
          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - vgs lvmvg >/dev/null 2>&1 || exit 1
            initialDelaySeconds: 30
            periodSeconds: 60
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - vgs lvmvg >/dev/null 2>&1 || exit 1
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 5
      volumes:
        - name: dev
          hostPath:
            path: /dev
        - name: sys
          hostPath:
            path: /sys
        - name: run
          hostPath:
            path: /run
        - name: etc-lvm
          hostPath:
            path: /etc/lvm
        - name: var-lib-lvm
          hostPath:
            path: /var/lib/lvm
        - name: proc
          hostPath:
            path: /proc
