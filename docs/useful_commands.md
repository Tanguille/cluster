# Useful Commands to Debug Kubernetes

## QOL

<https://github.com/ragrag/kubectl-autons>

```bash
# Auto-namespace
kubectl autons <command>
```

## Generate schematic

```bash
curl -X POST --data-binary @talos/schematic.yaml \
        https://factory.talos.dev/schematics
```

## Pod management

```bash
# Restart a deployment
kubectl rollout restart deployment -n <namespace> <deployment-name>

# Scale a deployment
kubectl scale deployment -n <namespace> <deployment-name> --replicas=<replicas>

# Create a debugging pod with networking tools
kubectl run tmp-shell --rm -i --tty --image nicolaka/netshoot -- /bin/bash

# Delete a pod
kubectl delete pod <pod-name>
```

## Logs

```bash
# Stream logs from a deployment
kubectl logs -n <namespace> deployment/<deployment-name> -f

# View deployment logs
kubectl logs -n <namespace> deployment/<deployment-name>

# Get detailed information about a deployment
kubectl describe -n <namespace> deployment/<deployment-name>
```

## Networking

```bash
# List all network policies in a namespace
kubectl get networkpolicies -n <namespace>

# Get all httproute resources across namespaces
kubectl get httproute -A

# List all services in a namespace
kubectl get services -n <namespace>

# Get endpoints across all namespaces
kubectl get -A endpoints

# Test internal service connectivity from debug pod
curl http://<service-name>.<namespace>.svc.cluster.local
```

## Storage

<https://github.com/clbx/kubectl-browse-pvc>

```bash
# Browse PVCs
kubectl browse-pvc

# Check mounted storage usage
kubectl exec -it -n <namespace> deployment/<deployment-name> -- df -h /path

# List persistent volume claims
kubectl get pvc --all-namespaces

# Execute commands in a pod
kubectl exec -it -n <namespace> deployment/<deployment-name> -- <command>
```

## Troubleshooting Failed HelmReleases

When a HelmRelease is stuck or failing to deploy (e.g., qBittorrent case):

```bash
# 1. Check HelmRelease status and events
kubectl describe helmrelease <release-name> -n <namespace>

# 2. Delete the failed HelmRelease to allow Flux to redeploy
kubectl delete helmrelease <release-name> -n <namespace>

# 3. Clean up any lingering resources
kubectl delete deployment <deployment-name> -n <namespace>
kubectl delete service <service-name> -n <namespace>

# 4. Force Flux to reconcile and redeploy
flux reconcile kustomization <kustomization-name> --with-source

# 5. Monitor the new deployment
kubectl get pods -n <namespace> -w
```

## Connecting Manually to a PostgreSQL Database

To connect manually to a CNPG PostgreSQL database using the secrets generated by the PostgreSQL operator, follow these steps:

1. **Retrieve the Application Credentials:**
   Get the username and password from the `-app` secret:

    ```bash
    # Get the username
    kubectl get secret -n database <cluster-name>-app -o jsonpath='{.data.username}' | base64 -d

    # Get the password
    kubectl get secret -n database <cluster-name>-app -o jsonpath='{.data.password}' | base64 -d
    ```

2. **Connect to the Database:**
   Use the retrieved credentials to connect to the PostgreSQL database using `psql`. Replace `<app-username>` and `<app-database-name>` with the actual values:

    ```bash
    psql -h <cluster-name>-rw.database.svc.cluster.local -U <app-username> -d <app-database-name> -W
    ```

    You will be prompted to enter the password.

### Notes

- The `-app` credentials should be used for application-level access, while the `-superuser` credentials are for administrative tasks only.

## Nextcloud Database Restore Process

When restoring a Nextcloud PostgreSQL database in Kubernetes:

1. **Create a debugging pod with database access:**

```bash
kubectl run tmp-shell --rm -i --tty --image nicolaka/netshoot -- /bin/bash
```

2. **Connect to PostgreSQL as postgres user:**

```bash
# Connect to the database
psql -h postgres16-rw.database.svc.cluster.local -U postgres -d nextcloud

# Grant all necessary permissions to nextcloud user
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO nextcloud;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO nextcloud;
GRANT ALL PRIVILEGES ON SCHEMA public TO nextcloud;
ALTER USER nextcloud CREATEDB;
GRANT CONNECT ON DATABASE nextcloud TO nextcloud;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL PRIVILEGES ON TABLES TO nextcloud;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL PRIVILEGES ON SEQUENCES TO nextcloud;
```

3. **Restore database backup:**

```bash
# Drop and recreate database if needed
PGPASSWORD="password" psql -h [server] -U [username] -d template1 -c "DROP DATABASE \"nextcloud\";"
PGPASSWORD="password" psql -h [server] -U [username] -d template1 -c "CREATE DATABASE \"nextcloud\";"

# Restore from backup
pg_restore -h postgres16-rw.database.svc.cluster.local \
    -U nextcloud \
    -d nextcloud \
    --clean \
    --if-exists \
    --no-owner \
    --no-privileges \
    --no-tablespaces \
    --no-comments \
    <backup-file>.sql
```

4. **After restore is complete, update Nextcloud data fingerprint:**

```bash
kubectl exec -it nextcloud-[pod-id] -c nextcloud -- \
    su -s /bin/sh www-data -c "php occ maintenance:data-fingerprint"
```

### Important Notes

- Always verify database permissions after restore
- The nextcloud user needs full privileges on the database
- Run maintenance:data-fingerprint after restore to help clients recover
- Consider putting Nextcloud in maintenance mode during restore:

```bash
# Enable maintenance mode
kubectl exec -it nextcloud-[pod-id] -c nextcloud -- \
    su -s /bin/sh www-data -c "php occ maintenance:mode --on"

# Disable maintenance mode
kubectl exec -it nextcloud-[pod-id] -c nextcloud -- \
    su -s /bin/sh www-data -c "php occ maintenance:mode --off"
```

## Talos Network Interface Speeds

To check the speed of network interfaces on Talos nodes:

```bash
# Check interface speeds for a specific node
talosctl --nodes <node-ip> get links -o yaml | grep -E "id:|speedMbit:|operationalState: up"

# Check all nodes (simple script)
for node_ip in 192.168.0.11 192.168.0.12 192.168.0.13; do
  echo "=== Node: $node_ip ==="
  talosctl --nodes $node_ip get links -o yaml 2>/dev/null | \
    awk '
      BEGIN { name=""; speed=""; state=""; type="" }
      /^    id:/ { name=$2 }
      /^    type:/ { type=$2 }
      /^    speedMbit:/ { speed=$2 }
      /^    operationalState:/ { state=$2 }
      /^---$/ {
        if (name && state == "up" && type == "ether" && !match(name, /^lxc/)) {
          if (speed == "" || speed == "4294967295") {
            printf "  %-20s %s\n", name, "N/A (virtual/unknown)"
          } else {
            printf "  %-20s %s Mbps\n", name, speed
          }
        }
        name=""; speed=""; state=""; type=""
      }
      END {
        if (name && state == "up" && type == "ether" && !match(name, /^lxc/)) {
          if (speed == "" || speed == "4294967295") {
            printf "  %-20s %s\n", name, "N/A (virtual/unknown)"
          } else {
            printf "  %-20s %s Mbps\n", name, speed
          }
        }
      }
    ' | sort
  echo ""
done
```

### Notes

- The `speedMbit` field shows the interface speed in Mbps
- Value `4294967295` typically indicates a virtual interface or unknown speed
- Physical interfaces will show their actual link speed (e.g., 1000, 2500, 10000)
- Cilium virtual interfaces (cilium_host, cilium_net) may show speeds but are virtual
